{"mappings":"AAOA,0BAA0B;IACxB,OAAO,CAAC,EAAE,OAAO,OAAO,CAAC;IACzB,QAAQ,CAAC,EAAE,OAAO,QAAQ,CAAC;IAC3B,MAAM,CAAC,EAAE,OAAO,MAAM,CAAC;CACxB,CAAC;AACF,+BAA+B,IAAI,GAAE,WAAgB,GAAG;IACtD,KAAK,EAAE,OAAO,WAAW,KAAK,CAAC;IAC/B,OAAO,EAAE,OAAO,WAAW,OAAO,CAAC;IACnC,OAAO,EAAE,OAAO,OAAO,CAAC;CACzB,CA8JA","sources":["proxy/factory/proxy/factory/index.ts","proxy/factory/index.ts"],"sourcesContent":[null,"\n// import { polyfillKeys } from \"@portal-solutions/semble-common\";\nimport {\n  isPolyfillKey,\n  protoChained as protoChainedCommon,\n} from \"@portal-solutions/semble-common\";\nimport { descGet, descSet, desc } from \"@portal-solutions/semble-common\";\nexport type FactoryOpts = {\n  WeakMap?: typeof WeakMap;\n  Function?: typeof Function;\n  Object?: typeof Object;\n};\nexport default function create(opts: FactoryOpts = {}): {\n  Proxy: typeof globalThis.Proxy;\n  Reflect: typeof globalThis.Reflect;\n  WeakMap: typeof WeakMap;\n} {\n  const _WeakMap = opts.WeakMap ?? globalThis.WeakMap;\n  const { Function = globalThis.Function, Object = globalThis.Object } = opts;\n  const _proxyData: WeakMap<any, { object: any; handler: ProxyHandler<any> }> =\n    new _WeakMap();\n\n  function protoChained<\n    T extends object,\n    X extends keyof T,\n    U,\n    Args extends unknown[]\n  >(\n    f: <T2 extends { [X2 in X]: any }>(t: T2, key: X, ...args: Args) => U,\n    {\n      Reflect = _Reflect,\n    }: {\n      Reflect?: {\n        getPrototypeOf: typeof globalThis.Reflect.getPrototypeOf;\n        getOwnPropertyDescriptor: typeof globalThis.Reflect.getOwnPropertyDescriptor;\n      };\n    } = {}\n  ): (val: T, key: X, ...args: Args) => U {\n    return protoChainedCommon(f, { Reflect });\n  }\n\n  const _Reflect: typeof Reflect = {\n    apply: Function.prototype.apply.call.bind(Function.prototype.apply),\n    construct: (target, args, self) =>\n      _proxyData.has(target) && \"construct\" in _proxyData.get(target)!.handler!\n        ? _proxyData.get(target)!.handler.construct!(\n            _proxyData.get(target)!.object,\n            args,\n            self\n          )\n        : target === self\n        ? new target(...args)\n        : _Reflect.apply(target, self, args),\n    get: protoChained((object, key) =>\n      _proxyData.has(object) &&\n      \"get\" in _proxyData.get(object)!.handler &&\n      !isPolyfillKey(key)\n        ? _proxyData.get(object)!.handler.get!(\n            _proxyData.get(object)!.object,\n            key,\n            object\n          )\n        : descGet(object, key)\n    ),\n    set: protoChained((object, key, value) =>\n      _proxyData.has(object) &&\n      \"set\" in _proxyData.get(object)!.handler &&\n      !isPolyfillKey(key)\n        ? _proxyData.get(object)!.handler.set!(\n            _proxyData.get(object)!.object,\n            key,\n            value,\n            object\n          )\n        : (descSet(object, key, value as any), true)\n    ),\n    has: protoChained((object, key) =>\n      _proxyData.has(object) &&\n      \"has\" in _proxyData.get(object)!.handler &&\n      !isPolyfillKey(key)\n        ? _proxyData.get(object)!.handler.has!(\n            _proxyData.get(object)!.object,\n            key\n          )\n        : desc(object, key) !== null\n    ),\n\n    setPrototypeOf: ((old, object, proto) => (old(object, proto), true)).bind(\n      null,\n      \"setPrototypeOf\" in Object\n        ? Object.setPrototypeOf.bind(Object)\n        : (object, proto) => ((object.__proto__ = proto), object)\n    ),\n  } as any;\n  const _Proxy: typeof Proxy = class ProxyTemp extends Function {\n    static __call = Function.prototype.call.call.bind(Function.prototype.call);\n    constructor(object, handler: ProxyHandler<any>) {\n      if (false) super(); //Obey TS\n      const m = ProxyTemp.__create(object, handler);\n      _Reflect.setPrototypeOf(m, ProxyTemp.prototype);\n      return m;\n    }\n    static __create(object, handler: ProxyHandler<any>) {\n      const fn = function (...args) {\n        if (this instanceof fn) {\n          if (\"construct\" in handler) {\n            return handler.construct!(object, args, new.target);\n          }\n          return new object(...args);\n        } else {\n          if (\"apply\" in handler) {\n            return handler.apply!(object, this, args);\n          }\n          return ProxyTemp.__call(object, this, ...args);\n        }\n      };\n      _proxyData.set(fn, { object, handler });\n      return fn;\n    }\n    static {\n      for (const trap of [\n        \"defineProperty\",\n        \"getOwnPropertyDescriptor\",\n        \"getOwnPropertyDescriptors\",\n        \"freeze\",\n        \"seal\",\n        \"preventExtensions\",\n        \"getPrototypeOf\",\n        \"setPrototypeOf\",\n      ]) {\n        if (trap in Object) {\n          _Reflect[trap] = new ProxyTemp(\n            trap in _Reflect ? _Reflect[trap] : Object[trap].bind(Object),\n            {\n              apply(target, self, args) {\n                if (_proxyData.has(args[0])) {\n                  if (trap in _proxyData.get(args[0])?.handler!) {\n                    return _proxyData.get(args[0])?.handler?.[trap]?.(...args);\n                  } else {\n                    args[0] = _proxyData.get(args[0])!.object;\n                    return _Reflect.apply(target, self, args);\n                  }\n                } else {\n                  return _Reflect.apply(target, self, args);\n                }\n              },\n            }\n          );\n          Object[trap] = new ProxyTemp(Object[trap], {\n            apply(target, self, args) {\n              if (_proxyData.has(args[0])) {\n                if (trap in _proxyData.get(args[0])?.handler!) {\n                  return _proxyData.get(args[0])?.handler?.[trap]?.(...args);\n                } else {\n                  args[0] = _proxyData.get(args[0])!.object;\n                  return _Reflect.apply(target, self, args);\n                }\n              } else {\n                return _Reflect.apply(target, self, args);\n              }\n            },\n          });\n        }\n      }\n      Function.prototype.toString = new ProxyTemp(Function.prototype.toString, {\n        apply(target, thisArg, argArray) {\n          while (_proxyData.has(thisArg))\n            thisArg = _proxyData.get(thisArg)!.object;\n          return _Reflect.apply(target, thisArg, argArray);\n        },\n      }) as any;\n    }\n  } as any;\n  return { Proxy: _Proxy, Reflect: _Reflect, WeakMap: _WeakMap };\n}\n"],"names":[],"version":3,"file":"index.d.ts.map"}