{"mappings":"AAAA;IACE,MAAM,EAAE,MAAM,CAAC;CAChB;AACD,OAAO,IAAI,MAAM,IAAI,GAAG,IAAW,CAAC;AACpC,OAAO,IAAI,oFAAmE,CAAC;AAE/E,OAAO,IAAI,8FAA+C,CAAC;AAa3D,qBAAqB,CAAC,SAAS,MAAM,EAAE,CAAC,SAAS,MAAM,CAAC,EACtD,GAAG,EAAE,CAAC,EACN,GAAG,EAAE,CAAC,GACL,kBAAkB,CA4BpB;AACD,wBAAwB,CAAC,SAAS,MAAM,EAAE,CAAC,SAAS,MAAM,CAAC,EACzD,GAAG,EAAE,CAAC,EACN,GAAG,EAAE,CAAC,GACL,CAAC,CAAC,CAAC,CAAC,CAON;AACD,wBAAwB,CAAC,SAAS,MAAM,EAAE,CAAC,SAAS,MAAM,CAAC,EACzD,GAAG,EAAE,CAAC,EACN,GAAG,EAAE,CAAC,EACN,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,GACR,CAAC,CAAC,CAAC,CAAC,CAON;AACD,yCAAyC,CAAC,SAAS,MAAM,EAAE,CAAC,SAAS,MAAM,CAAC,EAC1E,MAAM,EAAE,CAAC,EACT,GAAG,EAAE,CAAC,EACN,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,EACT,OAAM,kBAAuB,GAC5B,CAAC,CAAC,CAAC,CAAC,CAWN;ACxFD,OAAO,MAAM,gBAAiB,CAAC;AA0B/B,OAAO,MAAM,gBAAiB,MAAC,YAEO,CAAC;AAGvC,OAAO,MAAM,MAAM,CAAC,CAAC,EAAE,CAAC,SAAS,MAAM,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,KAAK,IAgB1D,CAAC;AACP,6BACE,CAAC,SAAS,MAAM,EAChB,CAAC,SAAS,MAAM,CAAC,EACjB,CAAC,EACD,IAAI,SAAS,OAAO,EAAE,EAEtB,CAAC,EAAE,CAAC,EAAE,SAAS;KAAG,EAAE,IAAI,CAAC,GAAG,GAAG;CAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,IAAI,EAAE,IAAI,KAAK,CAAC,EACrE,EACE,OAGC,GACF,GAAE;IACD,OAAO,CAAC,EAAE;QACR,cAAc,EAAE,OAAO,WAAW,OAAO,CAAC,cAAc,CAAC;QACzD,wBAAwB,EAAE,OAAO,WAAW,OAAO,CAAC,wBAAwB,CAAC;KAC9E,CAAC;CACE,GACL,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,IAAI,EAAE,IAAI,KAAK,CAAC,CAYtC","sources":["common/common/core_support.ts","common/common/index.ts","common/index.ts"],"sourcesContent":[null,null,"import { deft } from \"./core_support.ts\";\n\nexport const polyfillKeys = {};\nconst StringCharCodeAt = String.prototype.charCodeAt.call.bind(\n  String.prototype.charCodeAt\n);\nfunction startsWith(S: string, needle: string): boolean {\n  var searchStr = `${needle}`;\n\n  // var pos = ToIntegerOrInfinity(arguments.length > 1 ? arguments[1] : undefined);\n  // var len = S.length;\n  // var start = min(max(pos, 0), len);\n  var searchLength = searchStr.length;\n  var start = 0;\n\n  // Avoid the `indexOf` call if no match is possible\n  // if (searchLength + start > len) return false;\n\n  var index = -1;\n  while (++index < searchLength) {\n    if (\n      StringCharCodeAt(S, start + index) != StringCharCodeAt(searchStr, index)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\nexport const isPolyfillKey = (a) =>\n  ((typeof a === \"string\" || typeof a === \"symbol\") && a in polyfillKeys) ||\n  (deft && startsWith(a, deft.prefix));\nexport * from \"./core_support.ts\";\n\nexport const hide: <T, K extends keyof T>(object: T, key: K) => void =\n  (function () {\n    // check if we're in ES5\n    if (\n      typeof Object.getOwnPropertyNames === \"function\" &&\n      !(\"prototype\" in Object.getOwnPropertyNames)\n    ) {\n      var hidden = { enumerable: false };\n\n      return function (object, key) {\n        Object.defineProperty(object, key, hidden);\n      };\n    }\n\n    // noop for ES3\n    return function () {};\n  })();\nexport function protoChained<\n  T extends object,\n  X extends keyof T,\n  U,\n  Args extends unknown[]\n>(\n  f: <T2 extends { [X2 in X]: any }>(t: T2, key: X, ...args: Args) => U,\n  {\n    Reflect = {\n      getPrototypeOf: Object?.getPrototypeOf,\n      getOwnPropertyDescriptor: Object?.getOwnPropertyDescriptor,\n    },\n  }: {\n    Reflect?: {\n      getPrototypeOf: typeof globalThis.Reflect.getPrototypeOf;\n      getOwnPropertyDescriptor: typeof globalThis.Reflect.getOwnPropertyDescriptor;\n    };\n  } = {}\n): (val: T, key: X, ...args: Args) => U {\n  return (val, key, ...args) => {\n    for (;;) {\n      if (val === null) {\n        throw val[key]; //Throws before the `throw` statement\n      }\n      if (Reflect.getOwnPropertyDescriptor(val, key)) {\n        return f(val, key, ...args);\n      }\n      val = Reflect.getPrototypeOf(val) as T; //Simulate tail recursion\n    }\n  };\n}\n"],"names":[],"version":3,"file":"index.d.ts.map"}