{"mappings":"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","sources":["common/index.ts","common/core_support.ts"],"sourcesContent":["import { deft } from \"./core_support.ts\";\n\nexport const polyfillKeys = {};\nconst StringCharCodeAt = String.prototype.charCodeAt.call.bind(\n  String.prototype.charCodeAt\n);\nfunction startsWith(S: string, needle: string): boolean {\n  var searchStr = `${needle}`;\n\n  // var pos = ToIntegerOrInfinity(arguments.length > 1 ? arguments[1] : undefined);\n  // var len = S.length;\n  // var start = min(max(pos, 0), len);\n  var searchLength = searchStr.length;\n  var start = 0;\n\n  // Avoid the `indexOf` call if no match is possible\n  // if (searchLength + start > len) return false;\n\n  var index = -1;\n  while (++index < searchLength) {\n    if (\n      StringCharCodeAt(S, start + index) != StringCharCodeAt(searchStr, index)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\nexport const isPolyfillKey = (a) =>\n  ((typeof a === \"string\" || typeof a === \"symbol\") && a in polyfillKeys) ||\n  (deft && startsWith(a, deft.prefix));\nexport * from \"./core_support.ts\";\n\nexport const hide: <T, K extends keyof T>(object: T, key: K) => void =\n  (function () {\n    // check if we're in ES5\n    if (\n      typeof Object.getOwnPropertyNames === \"function\" &&\n      !(\"prototype\" in Object.getOwnPropertyNames)\n    ) {\n      var hidden = { enumerable: false };\n\n      return function (object, key) {\n        Object.defineProperty(object, key, hidden);\n      };\n    }\n\n    // noop for ES3\n    return function () {};\n  })();\nexport function protoChained<\n  T extends object,\n  X extends keyof T,\n  U,\n  Args extends unknown[]\n>(\n  f: <T2 extends { [X2 in X]: any }>(t: T2, key: X, ...args: Args) => U,\n  {\n    Reflect = {\n      getPrototypeOf: Object?.getPrototypeOf,\n      getOwnPropertyDescriptor: Object?.getOwnPropertyDescriptor,\n    },\n  }: {\n    Reflect?: {\n      getPrototypeOf: typeof globalThis.Reflect.getPrototypeOf;\n      getOwnPropertyDescriptor: typeof globalThis.Reflect.getOwnPropertyDescriptor;\n    };\n  } = {}\n): (val: T, key: X, ...args: Args) => U {\n  return (val, key, ...args) => {\n    for (;;) {\n      if (val === null) {\n        throw val[key]; //Throws before the `throw` statement\n      }\n      if (Reflect.getOwnPropertyDescriptor(val, key)) {\n        return f(val, key, ...args);\n      }\n      val = Reflect.getPrototypeOf(val) as T; //Simulate tail recursion\n    }\n  };\n}\n","interface Deft {\n  prefix: string;\n}\nexport let deft: Deft | null = null;\nexport let getOwnPropertyDescriptor = Object?.getOwnPropertyDescriptor ?? null;\nconst getPrototypeOf = Object?.getPrototypeOf ?? null;\nexport let defineProperty = Object?.defineProperty ?? null;\n// export let getOwnPropertyDescriptor;\nif (!defineProperty && !getOwnPropertyDescriptor) {\n  const prefix = `__SemblePropertyFor__`;\n  deft = { prefix };\n  defineProperty = (o, k, d) => {\n    if (typeof k === \"string\") o[`${prefix}_${k}`] = d;\n    if (\"value\" in d) o[k] = d.value;\n    return o;\n  };\n  getOwnPropertyDescriptor = (o, p) => desc(o, p);\n}\n\nexport function desc<T extends object, K extends keyof T>(\n  obj: T,\n  key: K\n): PropertyDescriptor {\n  if (deft) {\n    if (typeof key === \"string\" && `${deft.prefix}_${key}` in obj)\n      return (obj as any)[`${deft.prefix}_${key}`];\n    if (key in obj)\n      return {\n        [`${deft.prefix}_value`]: {\n          get() {\n            return obj[key];\n          },\n          set(v) {\n            obj[key] = v;\n          },\n        },\n      } as any as PropertyDescriptor;\n    return null;\n  } else {\n    if (key in obj) {\n      for (;;) {\n        let a = getOwnPropertyDescriptor(obj, key);\n        if (a) return a;\n        obj = getPrototypeOf(obj);\n        if (obj === null) return null;\n      }\n    } else {\n      return null;\n    }\n  }\n}\nexport function descGet<T extends object, K extends keyof T>(\n  obj: T,\n  key: K\n): T[K] {\n  if (!deft) return obj[key];\n  for (;;) {\n    let des = desc(obj, key);\n    if (\"get\" in des) return des.get();\n    [obj, key] = [des as any, \"value\" as any];\n  }\n}\nexport function descSet<T extends object, K extends keyof T>(\n  obj: T,\n  key: K,\n  val: T[K]\n): T[K] {\n  if (!deft) return (obj[key] = val);\n  for (;;) {\n    let des = desc(obj, key);\n    if (\"set\" in des) return des.set(val), val;\n    [obj, key] = [des as any, \"value\" as any];\n  }\n}\nexport function setNonEnumerableBaseline<T extends object, K extends keyof T>(\n  object: T,\n  key: K,\n  val: T[K],\n  desc: PropertyDescriptor = {}\n): T[K] {\n  if (deft) {\n    return (object[key] = val);\n  }\n  defineProperty(object, key, {\n    writable: true,\n    ...desc,\n    enumerable: false,\n    value: val,\n  });\n  return val;\n}\n"],"names":[],"version":3,"file":"index.js.map"}