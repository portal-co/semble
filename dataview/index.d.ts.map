{"mappings":"AAuBA,OAAO,MAAM,cAAc,OAAO,WAmIvB,CAAC;AAIZ,OAAO,MAAM,WAAW,OAAO,QAqSpB,CAAC;AACZ,OAAO,MAAM,qBAAqB,GAA4G,CAAA","sources":["dataview/dataview/index.ts","dataview/index.ts"],"sourcesContent":[null,"import { _WeakMap } from \"@portal-solutions/semble-weak-map\";\nconst _data: WeakMap<any, number[]> = new _WeakMap();\nconst hide = (function () {\n    // check if we're in ES5\n    if (typeof Object.getOwnPropertyNames === 'function' && !('prototype' in Object.getOwnPropertyNames)) {\n        var hidden = { enumerable: false };\n\n        return function (object, key) {\n            Object.defineProperty(object, key, hidden);\n        };\n    }\n\n    // noop for ES3\n    return function () { };\n})();\n\nfunction define(object, props) {\n    for (var key in props) {\n        object[key] = props[key];\n    }\n}\nconst _Uint8Array = globalThis.Uint8Array ?? class UnusedUint8Array { };\n\nexport const _ArrayBuffer: typeof ArrayBuffer = 'ArrayBuffer' in globalThis ? globalThis.ArrayBuffer : (function () {\n    var min = Math.min,\n        max = Math.max,\n        char = String.fromCharCode;\n\n    var chars: { [a: string]: number } = {},\n        indices: string[] = [];\n\n    // create cached mapping of characters to char codes and back\n    void function () {\n        for (var i = 0; i < 0x100; ++i) {\n            chars[indices[i] = char(i)] = i;\n            if (i >= 0x80) {\n                chars[char(0xf700 + i)] = i;\n            }\n        }\n    }();\n\n    // read a string into an array of bytes\n    function readString(string) {\n        var array: number[] = [],\n            cycles = string.length % 8,\n            index = 0;\n\n        while (cycles--) {\n            array[index] = chars[string[index++]];\n        }\n\n        cycles = string.length >> 3;\n\n        while (cycles--) {\n            array.push(\n                chars[string[index]],\n                chars[string[index + 1]],\n                chars[string[index + 2]],\n                chars[string[index + 3]],\n                chars[string[index + 4]],\n                chars[string[index + 5]],\n                chars[string[index + 6]],\n                chars[string[index + 7]]\n            );\n            index += 8;\n        }\n\n        return array;\n    }\n\n    // write an array of bytes to a string\n    function writeString(array) {\n        try { return char.apply(null, array) } catch (e) { }\n\n        var string = '',\n            cycles = array.length % 8,\n            index = 0;\n\n        while (cycles--) {\n            string += indices[array[index++]];\n        }\n\n        cycles = array.length >> 3;\n\n        while (cycles--) {\n            string +=\n                indices[array[index]] +\n                indices[array[index + 1]] +\n                indices[array[index + 2]] +\n                indices[array[index + 3]] +\n                indices[array[index + 4]] +\n                indices[array[index + 5]] +\n                indices[array[index + 6]] +\n                indices[array[index + 7]];\n            index += 8;\n        }\n\n        return string;\n    }\n\n    // create a new array of given size where each element is 0\n    function zerodArray(size) {\n        var data = new Array(size);\n\n        for (var i = 0; i < size; i++) {\n            data[i] = 0;\n        }\n\n        return data;\n    }\n\n\n    // ###################\n    // ### ArrayBuffer ###\n    // ###################\n\n    function ArrayBuffer(length) {\n        if (length instanceof _ArrayBuffer) {\n            _data.set(this, (_data.get(length) ?? [...new _Uint8Array(length)]).slice());\n        } else if (typeof length === 'string') {\n            _data.set(this, readString(length));\n        } else {\n            if ((length >>= 0) < 0) {\n                throw new RangeError('ArrayBuffer length must be non-negative');\n            }\n            _data.set(this, zerodArray(length));\n        }\n\n        this.byteLength = _data.get(this)!.length;\n        //   hide(this, '_data');\n    }\n\n    define(ArrayBuffer, {\n        toByteString: function toByteString(arraybuffer) {\n            if (!(arraybuffer instanceof ArrayBuffer)) {\n                throw new TypeError('ArrayBuffer.toByteString requires an ArrayBuffer');\n            }\n\n            return writeString(_data.get(arraybuffer)!);\n        }\n    });\n\n    define(ArrayBuffer.prototype, {\n        slice: function slice(begin, end) {\n            var arraybuffer = new ArrayBuffer(0);\n\n            _data.set(arraybuffer, _data.get(this)!.slice(begin, end));\n            arraybuffer.byteLength = _data.get(arraybuffer)!.length;\n\n            return arraybuffer;\n        }\n    });\n\n    return ArrayBuffer;\n})() as any;\n\n\n\nexport const _DataView: typeof DataView = 'DataView' in globalThis ? globalThis.DataView : (function () {\n    var log = Math.log,\n        pow = Math.pow,\n        LN2 = Math.LN2;\n\n\n    // Joyent copyright applies to readFloat and writeFloat\n\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n    function readFloat(dataview, offset, littleEndian, mLen, bytes) {\n        var buffer = _data.get(dataview.buffer) ?? new _Uint8Array(dataview.buffer),\n            offset = dataview.byteOffset + offset,\n            e, m,\n            eLen = bytes * 8 - mLen - 1,\n            eMax = (1 << eLen) - 1,\n            eBias = eMax >> 1,\n            nBits = -7,\n            i = littleEndian ? bytes - 1 : 0,\n            d = littleEndian ? -1 : 1,\n            s = buffer[offset + i];\n\n        i += d;\n\n        e = s & ((1 << (-nBits)) - 1);\n        s >>= (-nBits);\n        nBits += eLen;\n        for (; nBits > 0; e = e * 0x100 + buffer[offset + i], i += d, nBits -= 8);\n\n        m = e & ((1 << (-nBits)) - 1);\n        e >>= (-nBits);\n        nBits += mLen;\n        for (; nBits > 0; m = m * 0x100 + buffer[offset + i], i += d, nBits -= 8);\n\n        if (e === 0) {\n            e = 1 - eBias;\n        } else if (e === eMax) {\n            return m ? NaN : s ? -Infinity : Infinity;\n        } else {\n            m = m + pow(2, mLen);\n            e = e - eBias;\n        }\n        return (s ? -1 : 1) * m * pow(2, e - mLen);\n    }\n\n    function writeFloat(dataview, offset, value, littleEndian, mLen, bytes) {\n        var buffer = _data.get(dataview.buffer) ?? new _Uint8Array(dataview.buffer),\n            offset = dataview.byteOffset + offset,\n            e, m, c,\n            eLen = bytes * 8 - mLen - 1,\n            eMax = (1 << eLen) - 1,\n            eBias = eMax >> 1,\n            rt = (mLen === 23 ? pow(2, -24) - pow(2, -77) : 0),\n            i = littleEndian ? 0 : bytes - 1,\n            d = littleEndian ? 1 : -1,\n            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n        value < 0 && (value = -value);\n\n        if (value !== value || value === Infinity) {\n            m = value !== value ? 1 : 0;\n            e = eMax;\n        } else {\n            e = (log(value) / LN2) | 0;\n            if (value * (c = pow(2, -e)) < 1) {\n                e--;\n                c *= 2;\n            }\n            if (e + eBias >= 1) {\n                value += rt / c;\n            } else {\n                value += rt * pow(2, 1 - eBias);\n            }\n            if (value * c >= 2) {\n                e++;\n                c /= 2;\n            }\n\n            if (e + eBias >= eMax) {\n                m = 0;\n                e = eMax;\n            } else if (e + eBias >= 1) {\n                m = (value * c - 1) * pow(2, mLen);\n                e = e + eBias;\n            } else {\n                m = value * pow(2, eBias - 1) * pow(2, mLen);\n                e = 0;\n            }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 0x100, mLen -= 8);\n\n        e = (e << mLen) | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 0x100, eLen -= 8);\n\n        buffer[offset + i - d] |= s * 0x80;\n    }\n\n\n    var le2 = [1, 0],\n        le4 = [3, 2, 1, 0],\n        be2 = [0, 1],\n        be4 = [0, 1, 2, 3];\n\n    function readUint8(dataview, byteOffset) {\n        var buffer = _data.get(dataview.buffer) ?? new _Uint8Array(dataview.buffer),\n            offset = byteOffset + dataview.byteOffset;\n\n        return buffer[offset];\n    }\n\n    function readUint16(dataview, byteOffset, littleEndian) {\n        var buffer = _data.get(dataview.buffer) ?? new _Uint8Array(dataview.buffer),\n            offset = byteOffset + dataview.byteOffset,\n            order = littleEndian ? le2 : be2;\n\n        var b0 = buffer[offset + order[0]],\n            b1 = buffer[offset + order[1]] << 8;\n\n        return b0 | b1;\n    }\n\n    function readUint32(dataview, byteOffset, littleEndian) {\n        var buffer = _data.get(dataview.buffer) ?? new _Uint8Array(dataview.buffer),\n            offset = byteOffset + dataview.byteOffset,\n            order = littleEndian ? le4 : be4;\n\n        var b0 = buffer[offset + order[0]],\n            b1 = buffer[offset + order[1]] << 8,\n            b2 = buffer[offset + order[2]] << 16,\n            b3 = buffer[offset + order[3]] << 24;\n\n        return b0 | b1 | b2 | b3;\n    }\n\n\n    function boundsCheck(offset, size, max) {\n        if (offset < 0) {\n            throw new RangeError('Tried to write to a negative index');\n        } else if (offset + size > max) {\n            throw new RangeError('Tried to write ' + size + ' bytes past the end of a buffer at index ' + offset + ' of ' + max);\n        }\n    }\n\n\n    function writeUint8(dataview, byteOffset, value) {\n        var buffer = _data.get(dataview.buffer) ?? new _Uint8Array(dataview.buffer),\n            offset = byteOffset + dataview.byteOffset;\n\n        boundsCheck(offset, 1, buffer.length);\n\n        buffer[offset] = value & 0xff;\n    }\n\n    function writeUint16(dataview, byteOffset, value, littleEndian) {\n        var buffer = _data.get(dataview.buffer) ?? new _Uint8Array(dataview.buffer),\n            order = littleEndian ? le2 : be2,\n            offset = byteOffset + dataview.byteOffset;\n\n        boundsCheck(offset, 2, buffer.length);\n\n        buffer[offset + order[0]] = value & 0xff;\n        buffer[offset + order[1]] = value >>> 8 & 0xff;\n    }\n\n    function writeUint32(dataview, byteOffset, value, littleEndian) {\n        var buffer = _data.get(dataview.buffer) ?? new _Uint8Array(dataview.buffer),\n            order = littleEndian ? le4 : be4,\n            offset = byteOffset + dataview.byteOffset;\n\n        boundsCheck(offset, 4, buffer.length);\n\n        buffer[offset + order[0]] = value & 0xff;\n        buffer[offset + order[1]] = value >>> 8 & 0xff;\n        buffer[offset + order[2]] = value >>> 16 & 0xff;\n        buffer[offset + order[3]] = value >>> 24 & 0xff;\n    }\n\n\n\n    // ################\n    // ### DataView ###\n    // ################\n\n    function DataView(buffer, byteOffset, byteLength) {\n        if (!(buffer instanceof _ArrayBuffer)) {\n            throw new TypeError('DataView must be initialized with an ArrayBuffer');\n        }\n\n        if (byteOffset === undefined) {\n            this.byteOffset = (buffer as any).byteOffset >> 0;\n        } else {\n            this.byteOffset = byteOffset >> 0;\n        }\n\n        if (this.byteOffset < 0) {\n            throw new RangeError('DataView byteOffset must be non-negative');\n        }\n\n\n        if (byteLength === undefined) {\n            this.byteLength = ((buffer as any).byteLength - this.byteOffset) >> 0;\n        } else {\n            this.byteLength = byteLength >> 0;\n        }\n\n        if (this.byteLength < 0) {\n            throw new RangeError('DataView byteLength must be non-negative');\n        }\n\n\n        if (this.byteOffset + this.byteLength > (buffer as any).byteLength) {\n            throw new RangeError('DataView byteOffset and byteLength greater than ArrayBuffer byteLength');\n        }\n\n        this.buffer = buffer;\n    }\n\n    define(DataView.prototype, {\n        getFloat32: function getFloat32(byteOffset, littleEndian) {\n            return readFloat(this, byteOffset, littleEndian, 23, 4);\n        },\n        getFloat64: function getFloat64(byteOffset, littleEndian) {\n            return readFloat(this, byteOffset, littleEndian, 52, 8);\n        },\n        getInt8: function getInt8(byteOffset) {\n            var n = readUint8(this, byteOffset);\n            return n & 0x80 ? n ^ -0x100 : n;\n        },\n        getInt16: function getInt16(byteOffset, littleEndian) {\n            var n = readUint16(this, byteOffset, littleEndian);\n            return n & 0x8000 ? n ^ -0x10000 : n;\n        },\n        getInt32: function getInt32(byteOffset, littleEndian) {\n            var n = readUint32(this, byteOffset, littleEndian);\n            return n & 0x80000000 ? n ^ -0x100000000 : n;\n        },\n        getUint8: function getUint8(byteOffset) {\n            return readUint8(this, byteOffset);\n        },\n        getUint16: function getUint16(byteOffset, littleEndian) {\n            return readUint16(this, byteOffset, littleEndian);\n        },\n        getUint32: function getUint32(byteOffset, littleEndian) {\n            return readUint32(this, byteOffset, littleEndian);\n        },\n        setFloat32: function setFloat32(byteOffset, value, littleEndian) {\n            writeFloat(this, byteOffset, value, littleEndian, 23, 4);\n        },\n        setFloat64: function setFloat64(byteOffset, value, littleEndian) {\n            writeFloat(this, byteOffset, value, littleEndian, 52, 8);\n        },\n        setInt8: function setInt8(byteOffset, value) {\n            writeUint8(this, byteOffset, value < 0 ? value | 0x100 : value);\n        },\n        setInt16: function setInt16(byteOffset, value, littleEndian) {\n            writeUint16(this, byteOffset, value < 0 ? value | 0x10000 : value, littleEndian);\n        },\n        setInt32: function setInt32(byteOffset, value, littleEndian) {\n            writeUint32(this, byteOffset, value < 0 ? value | 0x100000000 : value, littleEndian);\n        },\n        setUint8: function setUint8(byteOffset, value) {\n            writeUint8(this, byteOffset, value);\n        },\n        setUint16: function setUint16(byteOffset, value, littleEndian) {\n            writeUint16(this, byteOffset, value, littleEndian);\n        },\n        setUint32: function setUint32(byteOffset, value, littleEndian) {\n            writeUint32(this, byteOffset, value, littleEndian);\n        }\n    });\n\n    return DataView;\n})() as any;\nexport const _DataView_prototype: any = (x => Object.keys(x).reduce((p, c) => ({ ...p, [c]: x[c].call.bind(x[c]) }), {}))(_DataView.prototype)"],"names":[],"version":3,"file":"index.d.ts.map"}